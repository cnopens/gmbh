package main

import (
	"fmt"
	"math"
	"os"
	"path/filepath"
	"strconv"

	"github.com/gmbh-micro/config"
	"github.com/gmbh-micro/fileutil"
	"github.com/gmbh-micro/notify"
)

const (
	deployDir = "gmbh-deploy"
	doNotEdit = "# DO NOT EDIT\r\n# File automatically generated by gmbh\r\n"
	service   = `

[[service]]
id = "%s"
args = %s
env = %s
language = "%s"
bin_path = "%s"
src_path = "%s"`
	core = `[[service]]
args = %s
bin_path = "%s"`
)

type compNode struct {
	name string

	image   string
	env     []string
	envFile []string
	ports   []string
	ldriver string
}

func genDeploy(cfile string) {
	fmt.Println("Generating gmbh deployment")
	fmt.Println(". . .")
	conf, err := config.ParseSystemConfig(cfile)
	if err != nil {
		notify.LnRedF("could not parse config")
		return
	}

	fmt.Println("creating deployment directory")
	fileutil.MkDir("gmbh-deploy")

	// fmt.Println("linking config file to deployment directory")
	// cpath := notify.GetAbs(cfile) + "/" + filepath.Base(cfile)
	// print(cpath)
	// err = os.Symlink(cpath, deployDir+cfile[1:])
	// if err != nil {
	// why go, why?
	// if err.Error() != fmt.Sprintf("symlink %s %s: file exists", cpath, deployDir+cfile[1:]) {
	// notify.LnRedF(err.Error())
	// return
	// }
	// }

	fmt.Println("generating core node file")
	err = genCoreConf(conf)
	if err != nil {
		notify.LnRedF("could not create core node config")
		return
	}

	fmt.Println("generating node files")

	// why must you be like this, go?
	numNodes := math.Ceil(float64(len(conf.Service)) / float64(3))
	fmt.Printf("generating %d services in %d nodes\n", len(conf.Service), int(numNodes))

	nodes := []string{}

	for i := 0; i < int(numNodes); i++ {
		start := i * 3
		end := start + 3
		if end > len(conf.Service) {
			end = len(conf.Service)
		}

		thisNode := fmt.Sprintf("docker build -t gmbh-img-node_%d -f ./node_%d.Dockerfile --build-arg CACHEBUST=$(date +%s)  ../", i+1, i+1, "%s")
		nodes = append(nodes, thisNode)
		genNodeConf(i+1, conf.Service[start:end])
		genDockerfile(i+1, conf.Service[start:end])
	}

	fmt.Println("generating dockerfiles")
	fmt.Println("for core")
	f, err := fileutil.CreateFile(filepath.Join(deployDir, "core.Dockerfile"))
	if err != nil {
		return
	}
	f.WriteString(fmt.Sprintf(config.CoreDkr, cfile))
	f.Close()

	fmt.Println("for procm")
	g, err := fileutil.CreateFile(filepath.Join(deployDir, "procm.Dockerfile"))
	if err != nil {
		return
	}
	g.WriteString(config.ProcMDkr)
	g.Close()

	fmt.Println("generating build file")
	h, err := fileutil.CreateFile(filepath.Join(deployDir, "build.sh"))
	if err != nil {
		return
	}
	// h.WriteString(fmt.Sprintf(config.CoreDkr, cfile))
	h.WriteString(config.Bash)
	h.WriteString("docker build -t gmbh-img-core -f ./core.Dockerfile --build-arg CACHEBUST=$(date +%s) ../\n")
	h.WriteString(config.CheckBash)
	h.WriteString("docker build -t gmbh-img-procm -f ./procm.Dockerfile --build-arg CACHEBUST=$(date +%s)  ../\n")
	h.WriteString(config.CheckBash)
	for _, v := range nodes {
		h.WriteString(v + "\n")
		h.WriteString(config.CheckBash)
	}
	h.Close()

	err = os.Chmod(filepath.Join(deployDir, "build.sh"), 0755)
	if err != nil {
		fmt.Println(err.Error())
	}

	fmt.Println("generating docker compose file")
	m, err := fileutil.CreateFile(filepath.Join(deployDir, "docker-compose.yml"))
	if err != nil {
		return
	}
	m.WriteString(config.Compose)
	for i := 1; i < int(numNodes)+1; i++ {
		m.WriteString(fmt.Sprintf(config.ComposeNode, i, i, i))
	}
	m.Close()

	fmt.Println("generating env file")
	n, err := fileutil.CreateFile(filepath.Join(deployDir, "gmbh.env"))
	if err != nil {
		return
	}
	n.WriteString(config.EnvFile)
	n.Close()
}

// genCoreConf generates
func genCoreConf(config *config.SystemConfig) error {
	f, err := fileutil.CreateFile(filepath.Join(deployDir, "core.toml"))
	if err != nil {
		return err
	}
	w := f.WriteString
	w(doNotEdit)
	w("\n\n")
	w("fingerprint = \"" + l.fingerprint + "\"\n")
	w("\n")
	w(fmt.Sprintf(
		core,
		strArrtoStr([]string{"--verbose", "--config=./configFile.toml"}),
		"gmbhCore"),
	)

	f.Close()

	return nil
}

func genNodeConf(node int, services []*config.ServiceConfig) error {
	f, err := fileutil.CreateFile(filepath.Join(deployDir, "node_"+strconv.Itoa(node)+".toml"))
	if err != nil {
		return err
	}
	w := f.WriteString

	w(doNotEdit)
	w("#\n# Services in this file (by directory) \n")
	for _, s := range services {
		w(fmt.Sprintf("# - %s\n", fileutil.GetAbsFpath(s.BinPath)))
	}
	w("#\n# Fingerprint - the id that refers to this cluster\n")
	w(fmt.Sprintf("fingerprint = %s", "\"\""))

	base := 49500

	for i, s := range services {

		w(fmt.Sprintf(
			service,
			s.ID,
			strArrtoStr(s.Args),
			strArrtoStr(append(s.Env, "ADDR="+"node_"+strconv.Itoa(node)+":"+strconv.Itoa(base+((i+1)*20)))),
			s.Language,
			"/services/"+s.ID+"/"+filepath.Base(s.BinPath),
			s.SrcPath,
		))
	}

	f.Close()
	return nil
}

// genDockerfile will generate symbolic links to all of the services for each
// node and then create the docker file to add them to each image and include
// the best build instructions that we can
func genDockerfile(node int, services []*config.ServiceConfig) error {

	f, err := fileutil.CreateFile(filepath.Join(deployDir, "node_"+strconv.Itoa(node)+".Dockerfile"))
	if err != nil {
		return err
	}

	addLocs := []string{}
	makeInstrs := []string{}
	for _, s := range services {

		// err = os.Symlink(
		// 	fileutil.GetAbsFpath(s.SrcPath),
		// 	deployDir+"/services/"+s.ID,
		// )
		// if err != nil {
		// 	fmt.Println(err.Error())
		// 	return err
		// }
		addCmd := s.SrcPath + " ./" + s.ID
		addLocs = append(addLocs, addCmd)

		makeInstrs = append(makeInstrs, "cd ./"+s.ID+"; make")
	}

	addStr := ""
	for _, v := range addLocs {
		addStr += "ADD " + v + "\n"
	}

	makeStr := ""
	for _, v := range makeInstrs {
		makeStr += "RUN " + v + "\n"
	}

	nodeConf := "node_" + strconv.Itoa(node)
	f.WriteString(fmt.Sprintf(config.ServiceDkr, addStr, makeStr, nodeConf, nodeConf))

	f.Close()
	return nil
}
