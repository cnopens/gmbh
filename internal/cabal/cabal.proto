syntax = "proto3";
package cabal;

/*
 * RPC Service Cabal
 * Abe Dick
 * Nov 2018
 */


/* NOTE
 * 
 * To compile this file:
 * 
 * protoc --go_out=plugins=grpc:. *.proto
 */


/*
 * Service Cabal
 *
 * All cabal coms with be implemented through this service, this it needs to be able to handle both
 * ends of the server/client model including support for custom data models.
 * 
 */
service Cabal {

    /*
     * EphemeralRegisterService
     *
     * This should be used to for attaching services that use the generic data scheme and are considered
     * to be ephemeral to CabalCORE
     */
    rpc EphemeralRegisterService (RegServReq) returns (RegServRep) {}

    /*
     * AttachProcess
     *
     * This should be used for attaching services that have been registered with custom data schemes
     * that have been pre-established by CabalCORE
     */ 
    // rpc AttachProcess

    /*
     * UpdateServiceRegistration 
     *
     * This should be used to make changes to any registration information.
     */
     rpc UpdateServiceRegistration (ServiceUpdate) returns (ServiceUpdate) {}

    /*
     * MakeDataRequest
     *
     * Make all data requests between services through this method. 
     * *NOTE* This is a daft spec.
     */
    rpc MakeDataRequest (DataReq) returns (DataResp) {}

    /*
     * UnregisterService
     *
     * This should be used for graceful shutdown notice to CORE.
     */
    rpc UnregisterService (UnregisterReq) returns (UnregisterResp) {}

    /*
     * UpdatePermissionMap
     *
     * This should be used to update the permissions map that each service
     * should store.
     */
    // rpc UpdatePermissionMap

    /* 
     * QueryStatus
     *
     * Use this to query the status of all processes attached to CORE.
     */
    rpc QueryStatus (QueryRequest) returns (QueryResponse) {}

    rpc Alive (Ping) returns (Pong) {}
}


// Control runs communications between gmbh-core and gmbh-ctrl
service Control {

    rpc StartService (StartRequest) returns (StartReply) {}    
    rpc ListOne (SearchRequest) returns (ListReply) {}
    rpc RestartService (SearchRequest) returns (StatusReply) {}
    rpc KillService (SearchRequest) returns (StatusReply) {}

    rpc ListAll (AllRequest) returns (ListReply) {}
    rpc RestartAll (AllRequest) returns (StatusReply) {} 
    rpc KillAll (AllRequest) returns (StatusReply) {}

    // StopSever kills all of the attached services and then calls shutdown procedure
    rpc StopServer (StopRequest) returns (StatusReply) {}
    rpc ServerStatus (StatusRequest) returns (StatusReply) {}

    rpc UpdateServiceRegistration (ServiceUpdate) returns (ServiceUpdate) {}

    rpc Alive (Ping) returns (Pong) {}
}

service Remote {
    rpc UpdateServiceRegistration (ServiceUpdate) returns (ServiceUpdate) {}
    rpc RequestRemoteAction (Action) returns (Action) {}
    rpc Alive (Ping) returns (Pong) {}
}

message AllRequest {
    string Status = 1;
    string Sender = 2;
}

message RegServReq {
    // The service to register.
    NewService NewServ = 1;    
}

message RegServRep {

    // The status of the server
    string Status = 1;

    // The address to start new service host on
    string Address = 3;

    // The id that CORE assigned to this service
    string ID = 4;

    // The path to where the core instance is running
    // That is, the where the project root dir is.
    string CorePath = 5;

    // An array of all services.
    // *NOTE* This will need improvement as a full walk of all
    //        discoverable services must be done by walking each
    //        indice of the arrach and then walk the "Aliases" 
    //        field for a match.
    repeated S2S ServiceTable = 2;

    // the mode of the service
    string Mode = 6;

}

/*
 * NewService {message}
 *
 * The proto representation of a new service
 */ 
message NewService {

    // The name of the service
    string Name = 1;

    // Any aliases to recognize the service
    repeated string Aliases = 2;

    enum MMode {
        MANAGED = 0;
        REMOTE = 1;
        PLANETARY = 2;
    }
    MMode Mode = 5;

    // True if service can make data requests
    bool IsClient = 3;

    // True if service can handle data requests  
    bool IsServer = 4;
}

/*
 * S2S - Service To Service
 *
 * The proto representation of a service to be used for inter-service
 * communications that bypass CabalCORE
 */
message S2S {
    // The name of the service
    string Name = 1;

    // Any aliases to recognize the service
    repeated string Aliases = 2;

    // The complete location of the service.
    // Should be expressed as a complete URL if using TCP. If using load-balancers
    // it should be the location of the load balancer.
    string Location = 3;
    
}

message DataReq {
    // The Cabal Request object
    Request Req = 1;
}

message DataResp {
    // The Cabal Response object
    Responder Resp = 1;
}

message Request{
    string Sender = 1;
    string Target = 2;
    string Method = 3;
    string Data1 = 50;
}

message Responder{
    string Result = 50;
    string ErrorString = 98;
    bool HadError = 99;
}

message UnregisterReq {
    // The id of the service to unregister
    string id = 1;

    // The name of the service to unregister
    string name = 2;

    // the address of the service to unregister
    string address = 3;
}

message Status {
    string Sender = 1;
    string Target = 2;
    string Error = 10;
}

message UnregisterResp {
    // If CORE awknowledged the unregister reuqest
    bool ack = 6;

    Status status = 3;
}

message QueryRequest {

    enum QueryLevel {
        // Alive Ping
        STATUS = 0;

        // Report any errors w/ messages
        REPORT = 1;

        // Report start time, errors, etc.
        FULL = 2;
    }

    // The type of query -- see the enumerated type above
    QueryLevel Query = 1;
}

message QueryResponse {
    
    // if the process awknoledges request
    bool Awk = 1;

    // True if running without errors
    bool Status = 2;
    map<string, string> Details = 3;
    repeated string Errors = 4;
}

message StartRequest {
    string name = 1;
    string path = 2;
    bool binary = 3;
}

message SearchRequest {
    string Name = 1;
    bool managed = 5;
    string parentID = 6;
    string Path = 2;
    string Pid = 3;
    string Id = 4;

    string Sender = 10;
}

message StopRequest {
    string Status = 4;
}

message StatusReply {
    string status = 1;
}

message StatusRequest {
    string status = 1;
}

message StartReply {
    string Status = 3;
    bool Success = 1;
    int32 Pid = 2;
}

message ListReply {
    repeated Service managed = 6;
    repeated Service planetary = 7;
    repeated ProcessManager remote = 8;
    int32 length = 2;


    repeated ProcessManager remotes = 12;
    string Sender = 10;
    string Status = 9;
    
}

// Service holds data associated gimlet service
message Service {
    string Id = 10;
    string Name = 11;
    bool Registered = 22;
    string Mode = 23;
    string Address = 21;
    string Path = 12;
    string LogPath = 20;
    string Status = 14;
    int32 Restarts = 15;
    int32 Fails = 24;
    int32 Pid = 16;
    string StartTime = 17;
    string FailTime = 18;
    repeated string Errors = 19;
}

message ProcessManager {
    string ID = 1;
    string Name = 2;
    string Address = 3;
    repeated Service Services = 4;
}

message ServiceUpdate {
    string Sender = 1;
    string Target = 2;
    string Message = 3;
    string Status = 4;
    string Action = 5;

}

message Action {
    string Sender = 1;
    string Target = 2;
    string Message = 3;
    string Status = 4;
    string Action = 5;
    Service ServiceInfo = 6 ;
    repeated Service Services = 7;
    repeated ProcessManager remotes = 8;
}

message Ping {
    string Time = 1;
    string FromID = 2;
}

message Pong {
    string Time = 1;
}